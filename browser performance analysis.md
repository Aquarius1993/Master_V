## 一、浏览器加载过程：
### 1、建立连接过程

#### (1) 浏览器查找域名的IP地址
#### (2) 浏览器给web服务器发送一个HTTP请求
#### (3) 服务器发送永久重定向响应
#### (4) 浏览器跟踪重定向地址
#### (5) 服务器“处理”请求
#### (6) 服务器发回一个HTML响应
### 2、浏览器渲染

#### 解析HTML

##### ↓ HTML代码转化成DOM
##### 构建DOM树
##### ↓ CSS代码转化成CSSOM（CSS Object Model）,结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
##### 渲染树构建
##### ↓ 生成布局（layout），即将所有渲染树的所有节点进行平面合成
##### 渲染树布局
##### ↓ 将布局绘制（paint）在屏幕上
##### 绘制渲染树

以下三种情况，会导致网页重新渲染。
* 修改DOM
* 修改样式表
* 用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）
  
##### 重新渲染，就需要重新生成布局和重新绘制。前者叫做"重排"（reflow），后者叫做"重绘"（repaint）。
##### 需要注意的是，"重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。  

##### 重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。
##### 提高网页性能，就是要降低"重排"和"重绘"的频率和成本，尽量少触发重新渲染。
##### 前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。
`div.style.color = 'blue';
   div.style.marginTop = '30px';`
##### 上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。下面代码，代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。
`div.style.color = 'blue';
   var margin = parseInt(div.style.marginTop);
  div.style.marginTop = (margin + 10) + 'px';`

##### 一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。
##### 从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。
`// bad

div.style.left = div.offsetLeft + 10 + "px";
div.style.top = div.offsetTop + 10 + "px";

// good

var left = div.offsetLeft;
var top  = div.offsetTop;
div.style.left = left + 10 + "px";
div.style.top = top + 10 + "px";`

一般的规则是：
* 样式表越简单，重排和重绘就越快。
* 重排和重绘的DOM元素层级越高，成本就越高。
* table元素的重排和重绘成本，要高于div元素






